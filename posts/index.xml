<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on DomineCore Blogs</title>
    <link>https://DomineCore.github.io/posts/</link>
    <description>Recent content in Posts on DomineCore Blogs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Dec 2021 12:11:15 +0800</lastBuildDate>
    <atom:link href="https://DomineCore.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python｜drf常用view解析</title>
      <link>https://DomineCore.github.io/posts/drf%E5%B8%B8%E8%A7%81%E8%A7%86%E5%9B%BE%E5%89%96%E6%9E%90/</link>
      <pubDate>Wed, 01 Dec 2021 12:11:15 +0800</pubDate>
      <guid>https://DomineCore.github.io/posts/drf%E5%B8%B8%E8%A7%81%E8%A7%86%E5%9B%BE%E5%89%96%E6%9E%90/</guid>
      <description>1 APIView drf提供了一个继承自View类的APIView类，它比View多了一些好用的方法。&#xA;由APIView来对请求对象进行再次封装，将django的HttpRequest变为drf的Request 返回Response而不是HttpResponse 捕获所有的APIException并进行响应 传入的请求通过APIView来进行认证、权限验证等操作 1.1 APIView的AOP APIView保持了View的特性，dispatch方法在APIView里也存在，它按照不同的请求方法将请求分发至某个函数来处理。&#xA;继承自APIView的视图可以设置很多AOP(类属性)来进行认证、权限、频率、渲染等控制。&#xA;.render_classes：设置渲染器 .parser_classes：设置解析器 .authentication_classes：设置认证器 .throttle_classes：设置频率控制器 .permission_classes：设置权限控制器 1.2 策略方法 APIView也提供了一些策略方法：&#xA;.get_renderers(self) .get_parsers(self) .get_authenticators(self) .get_throttles(self) .get_permissions(self) .get_content_negotiator(self) .get_exception_handler(self) 这些策略方法会返回解析器、渲染器、频率控制器、权限控制器这些AOP的可调用对象列表：&#xA;def get_renderers(self): &amp;#34;&amp;#34;&amp;#34; Instantiates and returns the list of renderers that this view can use. &amp;#34;&amp;#34;&amp;#34; return [renderer() for renderer in self.renderer_classes] def get_parsers(self): &amp;#34;&amp;#34;&amp;#34; Instantiates and returns the list of parsers that this view can use. &amp;#34;&amp;#34;&amp;#34; return [parser() for parser in self.</description>
    </item>
    <item>
      <title>读书｜vue.js快跑</title>
      <link>https://DomineCore.github.io/posts/vue.js%E5%BF%AB%E8%B7%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 05 Jul 2021 20:14:45 +0800</pubDate>
      <guid>https://DomineCore.github.io/posts/vue.js%E5%BF%AB%E8%B7%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>vue.js，一个渐进式JavaScript框架，借助其优秀的响应式设计，提供了简单的数据状态到视图状态的双向映射。从原生js到jqury，react····，框架设计者们都在探索视图和数据之间的松耦合，以至于可以直接通过改变数据来改变视图。vue是在众多探索者中的一个把view和state之间的关系处理的恰到好处的渐进式框架。&#xA;为什么说它是渐进式呢？&#xA;其实vue的核心功能就是前面说到的：提供一个简单的数据状态到视图状态到双向映射，它更像是一个视图引擎，帮助开发者消除数据与视图之间的高耦合。在vue官网中，把这个功能称为——“声明式渲染”。&#xA;在vue生态中，我们可以通过添加组件系统，客户端路由，大规模状态管理，构建工具来让vue从一个“声明式渲染”引擎变为一个真正意义上的客户端开发框架，所以vue是“渐进式”的js框架（至少我是这么认为的，如果你有不同看法，洗耳恭听😄）。&#xA;这篇文章笔者准备围绕vue的核心功能——声明式渲染来介绍vue的入门级单文件用法，后面再结合组件系统，vuex，vue-router，webpack/vite等来介绍vue等工程化用法。&#xA;感受声明式渲染 我们前面提到，vue的核心就是它的声明式渲染，帮我们做好数据状态到视图状态的双向映射。&#xA;在《vue.js快跑》一书中，用模版、指令、数据解释了vue的组成部分，通过这些组成部分可以实现vue的声明式渲染（这里我们暂且不讨论原理）：&#xA;为正常的HTML添加特殊的属性——被称作指令——借助它来告诉vue我们想要实现的效果以及如何处理提供给它的数据。&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;button v-on:click=&amp;#34;change_show&amp;#34;&amp;gt;点我一下我就让你好看&amp;lt;/button&amp;gt; &amp;lt;span v-show=&amp;#34;show_word&amp;#34;&amp;gt;好看&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { show_word: false }, methods: { change_show:function(){ this.show_word = !this.show_word; } } }) &amp;lt;/script&amp;gt; 在上面的代码模型中。点击“点我一下我就让你好看”之后在页面上就会出现“好看”，在这个过程中，vue帮助我们实现了一个完整的交互和状态响应。&#xA;如果要使用原生js来实现上面的功能，我们需要考虑每一个实现细节：&#xA;1、捕获点击动作&#xA;2、更改状态变量值&#xA;3、根据改变后的状态变量值来渲染页面&#xA;而在vue中，我们只需要把一个数据和一个改变数据的方法声明在script中，并且通过vue的指令将两者建立联系，就可以实现”声明一个数据，通过改变数据改变状态”，我们不需要再关注其他的东西，因为这些vue已经帮助我们做好了。&#xA;v-if vs v-show 在前面的例子中我们已经了解到vue的声明式渲染大概是一个什么样子的，丰富的vue指令让我们可以更好的让数据和视图进行绑定。我们在前面的“点我一下就让你好看”的例子中使用了v-show这个指令，v-show指令是通过判断一个表达式或者变量的值是否为真来决定模版的渲染逻辑，它的作用有点像if语句。但实际上vue中也有专门的v-if用来控制条件渲染。&#xA;首先看看这两个指令的作用：&#xA;1、v-if：如果v-if指令的值为假，那么在渲染dom时，当前的元素就不会被插入dom&#xA;2、v-show：如果v-show的值为假，那么在显示dom的时候，这个元素不会被显示，它是css级别的控制&#xA;&amp;lt;div v-if=&amp;#34;true&amp;#34;&amp;gt; 😄 &amp;lt;/div&amp;gt; &amp;lt;div v-if=&amp;#34;false&amp;#34;&amp;gt; 👖 &amp;lt;/div&amp;gt; 上面的代码会被浏览器解析成这样的：&#xA;&amp;lt;div&amp;gt; 😄 &amp;lt;/div&amp;gt; 从这里就可以看到，v-if指令的值为false的元素并不会被加入最终的html中。&#xA;&amp;lt;div v-show=&amp;#34;true&amp;#34;&amp;gt; 😁 &amp;lt;/div&amp;gt; &amp;lt;div v-show=&amp;#34;false&amp;#34;&amp;gt; 👌 &amp;lt;/div&amp;gt; 浏览器解析这一段代码之后，它会产生这样的效果：</description>
    </item>
  </channel>
</rss>
